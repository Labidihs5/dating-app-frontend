generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String   @id // Telegram User ID
  telegramUsername String?  // @username from Telegram
  email            String?  // Email address
  name             String   // Display name (from Telegram, editable)
  age              Int      // Editable
  gender           String   // Editable
  bio              String?  // Optional
  photos           String[]
  profilePhotoIndex Int     @default(0) // Index of main profile photo
  isOnline         Boolean  @default(false)
  lastSeen         DateTime @default(now())
  location         Json?
  preferences      Json?
  relationshipType String   @default("serious")
  premiumStatus    String   @default("FREE") // FREE | GOLD

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  sentLikes     Like[] @relation("LikeSender")
  receivedLikes Like[] @relation("LikeReceiver")
  matches1      Match[] @relation("Match1")
  matches2      Match[] @relation("Match2")
  sentMessages  Message[] @relation("MessageSender")
  notifications Notification[]
  settings      UserSettings?
  ownedRooms    Room[] @relation("RoomOwner")
  roomMemberships NewRoomMember[]
  roomMessages    NewRoomMessage[]

  @@map("users")
}

model UserSettings {
  id                   String  @id @default(cuid())
  userId               String  @unique
  emailNotifications   Boolean @default(true)
  matchNotifications   Boolean @default(true)
  messageNotifications Boolean @default(true)
  pushNotifications    Boolean @default(true)
  darkMode             Boolean @default(false)
  profileVisibility    String  @default("public") // public, friends, private
  language             String  @default("en")
  hideExactLocation    Boolean @default(false)
  locationSharing      String  @default("exact") // exact, approximate, disabled
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_settings")
}

model Like {
  id         String   @id @default(cuid())
  senderId   String
  receiverId String
  isSuper    Boolean  @default(false)
  createdAt  DateTime @default(now())

  sender   User @relation("LikeSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("LikeReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@map("likes")
}

model Match {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())

  user1    User      @relation("Match1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("Match2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([user1Id, user2Id])
  @@map("matches")
}

model Message {
  id           String    @id @default(cuid())
  matchId      String
  senderId     String
  content      String
  isRead       Boolean   @default(false)
  isDelivered  Boolean   @default(false)
  createdAt    DateTime  @default(now())
  deliveredAt  DateTime?
  readAt       DateTime?

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender User  @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Notification {
  id         String   @id @default(cuid())
  userId     String
  type       String   // "match", "message", "like"
  title      String
  message    String
  data       Json?    // Additional data (matchId, senderId, etc.)
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
  readAt     DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model AiProfile {
  id               String   @id @default(cuid())
  name             String
  age              Int
  gender           String
  relationshipType String
  bio              String?
  interests        String[]
  photoUrl         String?
  city             String?
  country          String?
  aiPrompt         String?
  createdAt        DateTime @default(now())

  @@map("ai_profiles")
}

model DatingChallenge {
  id            String   @id @default(cuid())
  gameType      String?
  trigger       String?
  challengeText String
  difficulty    String?
  userId        String?
  targetId      String?
  createdAt     DateTime @default(now())

  @@map("dating_challenges")
}

model Game {
  id        String   @id @default(cuid())
  gameType  String
  mode      String
  player1Id String
  player2Id String?
  status    String   @default("active")
  state     Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  moves  GameMove[]
  result GameResult?

  @@map("games")
}

model GameMove {
  id        String   @id @default(cuid())
  gameId    String
  playerId  String
  move      Json
  createdAt DateTime @default(now())

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@map("game_moves")
}

model GameResult {
  id        String   @id @default(cuid())
  gameId    String   @unique
  winnerId  String?
  loserId   String?
  gameType  String?
  createdAt DateTime @default(now())

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@map("game_results")
}

model ChatRoom {
  id             String   @id @default(cuid())
  name           String
  type           String
  ownerId        String?
  isVerifiedOnly Boolean  @default(false)
  createdAt      DateTime @default(now())

  members  RoomMember[]
  messages RoomMessage[]

  @@map("chat_rooms")
}

model RoomMember {
  roomId   String
  userId   String
  joinedAt DateTime @default(now())

  room ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@id([roomId, userId])
  @@map("room_members")
}

model RoomMessage {
  id        String   @id @default(cuid())
  roomId    String
  userId    String
  content   String
  createdAt DateTime @default(now())

  room ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@map("room_messages")
}

model Room {
  id              String        @id @default(uuid())
  name            String
  description     String
  type            String        // PUBLIC | PRIVATE | EVENT
  category        String        // RESPECT | ADULT | SERIOUS | FUN | CITY
  isSystemRoom    Boolean       @default(false)
  ownerId         String?
  ageRestriction  Int           @default(0)
  createdAt       DateTime      @default(now())
  expiresAt       DateTime?
  
  owner           User?         @relation("RoomOwner", fields: [ownerId], references: [id])
  members         NewRoomMember[]  @relation("RoomMembers")
  messages        NewRoomMessage[] @relation("RoomMessages")
  invites         RoomInvite[]
  
  @@index([category])
  @@index([type])
  @@index([ownerId])
  @@map("rooms")
}

model NewRoomMember {
  id        String   @id @default(uuid())
  roomId    String
  userId    String
  role      String   // OWNER | MODERATOR | MEMBER
  joinedAt  DateTime @default(now())
  
  room      Room     @relation("RoomMembers", fields: [roomId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([roomId, userId])
  @@index([userId])
  @@map("room_members_new")
}

model NewRoomMessage {
  id        String   @id @default(uuid())
  roomId    String
  userId    String
  content   String   @db.Text
  createdAt DateTime @default(now())
  
  room      Room     @relation("RoomMessages", fields: [roomId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([roomId, createdAt])
  @@index([userId])
  @@map("room_messages_new")
}

model RoomInvite {
  id            String   @id @default(uuid())
  roomId        String
  invitedUserId String
  invitedBy     String
  status        String   @default("PENDING") // PENDING | ACCEPTED | DECLINED
  createdAt     DateTime @default(now())
  
  room          Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  @@unique([roomId, invitedUserId])
  @@index([invitedUserId])
  @@map("room_invites")
}
