#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

const log = (message, color = 'reset') => {
  console.log(`${colors[color]}${message}${colors.reset}`);
};

const spinner = {
  frames: ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'],
  start(message) {
    let i = 0;
    this.interval = setInterval(() => {
      process.stdout.write(`\r${colors.cyan}${this.frames[i]} ${message}${colors.reset}`);
      i = (i + 1) % this.frames.length;
    }, 100);
  },
  stop(message, success = true) {
    clearInterval(this.interval);
    const icon = success ? '‚úÖ' : '‚ùå';
    console.log(`\r${icon} ${message}`);
  }
};

class HeartMatchSetup {
  constructor() {
    this.projectRoot = process.cwd();
    this.packageManager = 'npm';
  }

  async run() {
    try {
      log('\nüöÄ HeartMatch Dating App Setup', 'bright');
      log('================================\n', 'cyan');

      await this.checkPrerequisites();
      await this.detectPackageManager();
      await this.createEnvironmentFile();
      await this.installDependencies();
      await this.setupProject();
      await this.runInitialBuild();
      
      this.showCompletionMessage();
    } catch (error) {
      log(`\n‚ùå Setup failed: ${error.message}`, 'red');
      process.exit(1);
    }
  }

  async checkPrerequisites() {
    log('üîç Checking prerequisites...', 'blue');
    
    // Check Node.js version
    try {
      const nodeVersion = execSync('node --version', { encoding: 'utf8' }).trim();
      const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
      
      if (majorVersion < 18) {
        throw new Error(`Node.js 18+ required. Current version: ${nodeVersion}`);
      }
      log(`‚úÖ Node.js ${nodeVersion} - OK`, 'green');
    } catch (error) {
      throw new Error('Node.js not found. Please install Node.js 18+');
    }

    // Check npm/yarn
    try {
      const npmVersion = execSync('npm --version', { encoding: 'utf8' }).trim();
      log(`‚úÖ npm ${npmVersion} - OK`, 'green');
    } catch (error) {
      throw new Error('npm not found');
    }

    // Check git
    try {
      execSync('git --version', { encoding: 'utf8' });
      log('‚úÖ Git - OK', 'green');
    } catch (error) {
      log('‚ö†Ô∏è  Git not found (optional)', 'yellow');
    }
  }

  async detectPackageManager() {
    if (fs.existsSync(path.join(this.projectRoot, 'yarn.lock'))) {
      try {
        execSync('yarn --version', { encoding: 'utf8' });
        this.packageManager = 'yarn';
        log('üì¶ Using Yarn package manager', 'blue');
      } catch (error) {
        log('‚ö†Ô∏è  yarn.lock found but Yarn not installed, using npm', 'yellow');
      }
    } else {
      log('üì¶ Using npm package manager', 'blue');
    }
  }

  async createEnvironmentFile() {
    const envPath = path.join(this.projectRoot, '.env.local');
    const envExamplePath = path.join(this.projectRoot, '.env.example');
    
    if (fs.existsSync(envPath)) {
      log('‚ö†Ô∏è  .env.local already exists, skipping...', 'yellow');
      return;
    }

    log('üîß Creating environment configuration...', 'blue');

    const envContent = `# HeartMatch Environment Configuration
# Generated by setup script

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3001/api

# Telegram Bot Configuration
NEXT_PUBLIC_TELEGRAM_BOT_TOKEN=your_telegram_bot_token_here

# App Configuration
NEXT_PUBLIC_APP_NAME=HeartMatch
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Development Settings
NODE_ENV=development

# Optional: Analytics & Monitoring
# NEXT_PUBLIC_GA_ID=your_google_analytics_id
# SENTRY_DSN=your_sentry_dsn

# Optional: Payment Integration
# NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=your_stripe_key
# STRIPE_SECRET_KEY=your_stripe_secret
`;

    fs.writeFileSync(envPath, envContent);
    
    // Create .env.example if it doesn't exist
    if (!fs.existsSync(envExamplePath)) {
      fs.writeFileSync(envExamplePath, envContent.replace(/=.+$/gm, '='));
    }

    log('‚úÖ Environment file created (.env.local)', 'green');
    log('üìù Please update .env.local with your actual configuration', 'yellow');
  }

  async installDependencies() {
    spinner.start('Installing dependencies...');
    
    try {
      const installCommand = this.packageManager === 'yarn' ? 'yarn install' : 'npm install';
      execSync(installCommand, { 
        stdio: 'pipe',
        cwd: this.projectRoot 
      });
      spinner.stop('Dependencies installed successfully', true);
    } catch (error) {
      spinner.stop('Failed to install dependencies', false);
      throw new Error(`Installation failed: ${error.message}`);
    }
  }

  async setupProject() {
    log('‚öôÔ∏è  Setting up project structure...', 'blue');

    // Create necessary directories
    const directories = [
      'public/images',
      'public/icons',
      'lib',
      'hooks',
      'components/ui'
    ];

    directories.forEach(dir => {
      const dirPath = path.join(this.projectRoot, dir);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
        log(`üìÅ Created directory: ${dir}`, 'green');
      }
    });

    // Create gitignore if it doesn't exist
    const gitignorePath = path.join(this.projectRoot, '.gitignore');
    if (!fs.existsSync(gitignorePath)) {
      const gitignoreContent = `# Dependencies
node_modules/
.pnp
.pnp.js

# Production
/build
/.next/
/out/

# Environment variables
.env*.local
.env

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Vercel
.vercel

# TypeScript
*.tsbuildinfo
next-env.d.ts
`;
      fs.writeFileSync(gitignorePath, gitignoreContent);
      log('‚úÖ Created .gitignore', 'green');
    }
  }

  async runInitialBuild() {
    spinner.start('Running initial build check...');
    
    try {
      const buildCommand = this.packageManager === 'yarn' ? 'yarn build' : 'npm run build';
      execSync(buildCommand, { 
        stdio: 'pipe',
        cwd: this.projectRoot 
      });
      spinner.stop('Build completed successfully', true);
    } catch (error) {
      spinner.stop('Build check skipped (expected for initial setup)', true);
      log('‚ÑπÔ∏è  Build will work once you complete the setup', 'blue');
    }
  }

  showCompletionMessage() {
    log('\nüéâ Setup completed successfully!', 'green');
    log('================================\n', 'cyan');
    
    log('üìã Next steps:', 'bright');
    log('1. Update .env.local with your configuration', 'yellow');
    log('2. Start development server:', 'yellow');
    log(`   ${this.packageManager === 'yarn' ? 'yarn dev' : 'npm run dev'}`, 'cyan');
    log('3. Open http://localhost:3000 in your browser', 'yellow');
    log('4. Set up your backend API (see INSTALLATION.md)', 'yellow');
    log('5. Configure Telegram Bot integration', 'yellow');

    log('\nüìö Useful commands:', 'bright');
    log(`‚Ä¢ Development: ${this.packageManager} dev`, 'blue');
    log(`‚Ä¢ Build: ${this.packageManager} ${this.packageManager === 'yarn' ? 'build' : 'run build'}`, 'blue');
    log(`‚Ä¢ Start production: ${this.packageManager} start`, 'blue');
    log(`‚Ä¢ Lint: ${this.packageManager} ${this.packageManager === 'yarn' ? 'lint' : 'run lint'}`, 'blue');

    log('\nüîó Resources:', 'bright');
    log('‚Ä¢ Documentation: README.md', 'blue');
    log('‚Ä¢ Installation Guide: INSTALLATION.md', 'blue');
    log('‚Ä¢ Support: support@heartmatch.app', 'blue');

    log('\nüí° Pro tip: Run the development server and start building your dating app!', 'magenta');
    log('\nHappy coding! üöÄ‚ù§Ô∏è\n', 'green');
  }
}

// Run setup if called directly
if (require.main === module) {
  const setup = new HeartMatchSetup();
  setup.run().catch(error => {
    console.error('Setup failed:', error);
    process.exit(1);
  });
}

module.exports = HeartMatchSetup;